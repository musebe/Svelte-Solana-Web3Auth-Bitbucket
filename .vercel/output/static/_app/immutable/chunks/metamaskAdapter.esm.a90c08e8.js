import{o as u,d as n,j as E,C as p,w as v,p as c,A as s,W as w,m as o,e as f,k as l,X as A}from"./authFunctions.a8864b2c.js";import{B as k}from"./baseEvmAdapter.esm.87bb7bf8.js";function g({mustBeMetaMask:d=!1,silent:e=!1,timeout:i=3e3}={}){r();let t=!1;return new Promise(a=>{window.ethereum?h():(window.addEventListener("ethereum#initialized",h,{once:!0}),setTimeout(()=>{h()},i));function h(){if(t)return;t=!0,window.removeEventListener("ethereum#initialized",h);const{ethereum:m}=window;m&&(!d||m.isMetaMask)?a(m):(!e&&console.error("@metamask/detect-provider:",d&&m?"Non-MetaMask window.ethereum detected.":"Unable to detect window.ethereum."),a(null))}});function r(){if(typeof d!="boolean")throw new Error("@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.");if(typeof e!="boolean")throw new Error("@metamask/detect-provider: Expected option 'silent' to be a boolean.");if(typeof i!="number")throw new Error("@metamask/detect-provider: Expected option 'timeout' to be a number.")}}var C=g;const P=u(C);class R extends k{constructor(){super(...arguments),n(this,"adapterNamespace",E.EIP155),n(this,"currentChainNamespace",p.EIP155),n(this,"type",v.EXTERNAL),n(this,"name",c.METAMASK),n(this,"status",s.NOT_READY),n(this,"metamaskProvider",null)}get provider(){return this.status!==s.NOT_READY&&this.metamaskProvider?this.metamaskProvider:null}set provider(e){throw new Error("Not implemented")}async init(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(await super.init(e),super.checkInitializationRequirements(),this.metamaskProvider=await P({mustBeMetaMask:!0,silent:!0,timeout:1e3}),!this.metamaskProvider)throw w.notInstalled("Metamask extension is not installed");this.status=s.READY,this.emit(o.READY,c.METAMASK);try{f.debug("initializing metamask adapter"),e.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(i){this.emit(o.ERRORED,i)}}async connect(){if(super.checkConnectionRequirements(),!this.metamaskProvider)throw l.notConnectedError("Not able to connect with metamask");const{ethereum:e}=window,i="isPhantom"in e;if(e&&e.isMetaMask&&i){if(e.providers&&e.providers.length>0){const t=e.providers.find(r=>r.isMetaMask&&!r.overrideIsMetaMask);t&&e.setProvider(t)}}else if(e&&(e.providers||[]).length>0){const t=e.providers.find(r=>r.isMetaMask);t&&e.setSelectedProvider(t)}this.status=s.CONNECTING,this.emit(o.CONNECTING,{adapter:c.METAMASK});try{await this.metamaskProvider.request({method:"eth_requestAccounts"});const{chainId:t}=this.metamaskProvider;if(t!==this.chainConfig.chainId&&(await this.addChain(this.chainConfig,!0),await this.switchChain(this.chainConfig,!0)),this.status=s.CONNECTED,!this.provider)throw l.notConnectedError("Failed to connect with provider");const r=()=>{var a;this.disconnect(),(a=this.provider)===null||a===void 0||a.removeListener("disconnect",r)};return this.provider.on("disconnect",r),this.emit(o.CONNECTED,{adapter:c.METAMASK,reconnected:this.rehydrated}),this.provider}catch(t){throw this.status=s.READY,this.rehydrated=!1,this.emit(o.ERRORED,t),t instanceof A?t:l.connectionError("Failed to login with metamask wallet")}}async disconnect(){var e;let i=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{cleanup:!1};await super.disconnectSession(),(e=this.provider)===null||e===void 0||e.removeAllListeners(),i.cleanup?(this.status=s.NOT_READY,this.metamaskProvider=null):this.status=s.READY,await super.disconnect()}async getUserInfo(){if(this.status!==s.CONNECTED)throw l.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async addChain(e){var i;let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;super.checkAddChainRequirements(e,t),await((i=this.metamaskProvider)===null||i===void 0?void 0:i.request({method:"wallet_addEthereumChain",params:[{chainId:e.chainId,chainName:e.displayName,rpcUrls:[e.rpcTarget],blockExplorerUrls:[e.blockExplorer],nativeCurrency:{name:e.tickerName,symbol:e.ticker,decimals:e.decimals||18}}]})),this.addChainConfig(e)}async switchChain(e){var i;let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;super.checkSwitchChainRequirements(e,t),await((i=this.metamaskProvider)===null||i===void 0?void 0:i.request({method:"wallet_switchEthereumChain",params:[{chainId:e.chainId}]})),this.setAdapterSettings({chainConfig:this.getChainConfig(e.chainId)})}}export{R as MetamaskAdapter};
